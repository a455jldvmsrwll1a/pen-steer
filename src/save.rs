use std::{
    fmt::Write as FmtWrite,
    fs::OpenOptions,
    io::{BufWriter, Read, Write},
    path::Path,
};

use anyhow::{Context, Result, bail};
use log::error;

use crate::{
    config::{Config, Device, Source},
    mapping::MapOrientation,
};

#[derive(Debug)]
pub struct ParseError {
    msg: String,
    line: usize,
}

pub fn save_file(config: &Config, path: &Path) -> Result<()> {
    let file = OpenOptions::new()
        .write(true)
        .truncate(true)
        .create(true)
        .open(path)
        .context("Couldn't access file for writing.")?;
    let mut w = BufWriter::new(file);

    writeln!(&mut w, "; pen-steer configuration file")?;
    writeln!(&mut w, "; this file is automatically generated")?;
    writeln!(&mut w, ";")?;
    writeln!(&mut w)?;

    writeln!(&mut w, "update_frequency = {}", config.update_frequency)?;
    writeln!(&mut w, "range = {}", config.range)?;
    writeln!(&mut w, "horn_radius = {}", config.horn_radius)?;
    writeln!(&mut w, "pressure_threshold = {}", config.pressure_threshold)?;
    writeln!(&mut w, "base_radius = {}", config.base_radius)?;
    writeln!(&mut w)?;

    writeln!(&mut w, "inertia = {}", config.inertia)?;
    writeln!(&mut w, "friction = {}", config.friction)?;
    writeln!(&mut w, "spring = {}", config.spring)?;
    writeln!(&mut w, "max_torque = {}", config.max_torque)?;
    writeln!(&mut w)?;

    writeln!(
        &mut w,
        "map_input_rect = {} {} {} {}",
        config.mapping.min_in_x,
        config.mapping.min_in_y,
        config.mapping.max_in_x,
        config.mapping.max_in_y
    )?;
    writeln!(
        &mut w,
        "map_output_rect = {} {} {} {}",
        config.mapping.min_out_x,
        config.mapping.min_out_y,
        config.mapping.max_out_x,
        config.mapping.max_out_y
    )?;
    writeln!(
        &mut w,
        "map_orientation = {}",
        match config.mapping.orientation {
            MapOrientation::None => "A0",
            MapOrientation::A90 => "A90",
            MapOrientation::A180 => "A180",
            MapOrientation::A270 => "A270",
        }
    )?;
    writeln!(
        &mut w,
        "map_invert = {}",
        match (config.mapping.invert_x, config.mapping.invert_y) {
            (false, false) => "",
            (false, true) => "y",
            (true, false) => "x",
            (true, true) => "xy",
        }
    )?;
    writeln!(&mut w)?;

    writeln!(&mut w, "net_sock_addr = {}", config.net_sock_addr)?;
    writeln!(&mut w)?;

    writeln!(&mut w, "device_resolution = {}", config.device_resolution)?;
    writeln!(&mut w, "device_name = {}", config.device_name)?;
    writeln!(
        &mut w,
        "device_id = {:04X} {:04X} {:04X}",
        config.device_vendor, config.device_product, config.device_version
    )?;
    writeln!(&mut w)?;

    writeln!(
        &mut w,
        "preferred_tablet = {}",
        config.preferred_tablet.as_deref().unwrap_or_default()
    )?;
    writeln!(&mut w)?;

    writeln!(&mut w, "source = {:?}", config.source)?;
    writeln!(&mut w, "device = {:?}", config.device)?;
    writeln!(&mut w)?;

    Ok(())
}

pub fn compile_parse_errors(errors: Vec<ParseError>) -> String {
    const MAX_ERRORS: usize = 30;

    let mut message = String::new();
    let mut lines_left = MAX_ERRORS;
    let mut errors_left = errors.len();

    writeln!(
        &mut message,
        "{} parsing errors encountered while loading configuration file:",
        errors.len()
    )
    .unwrap();
    for error in errors {
        if lines_left == 0 {
            break;
        }

        writeln!(&mut message, "    line {}: {}", error.line + 1, error.msg).unwrap();
        lines_left -= 1;
        errors_left -= 1;
    }

    if errors_left > 0 {
        writeln!(&mut message, "... and {errors_left} more!").unwrap();
    }

    message.push('\n');

    message
}

pub fn load_file(config: &mut Config, path: &Path) -> Result<Vec<ParseError>> {
    let mut file = OpenOptions::new().read(true).open(path)?;
    let mut content = String::new();
    file.read_to_string(&mut content)?;

    config.source = Source::None;
    config.device = Device::None;

    let mut errors = vec![];
    for (line, text) in content.lines().enumerate() {
        if let Err(err) = load_from_line(config, text.trim()) {
            let parse_err = ParseError {
                line,
                msg: err.to_string(),
            };

            error!(
                "{} at line {}: {}\n --> {}\n",
                path.display(),
                line + 1,
                parse_err.msg,
                text
            );

            errors.push(parse_err);
        }
    }

    Ok(errors)
}

fn load_from_line(config: &mut Config, text: &str) -> Result<()> {
    // Ignore empty lines and comments.
    if text.is_empty() || text.starts_with('#') || text.starts_with(';') {
        return Ok(());
    }

    let (key, value) = tokenise_kv_line(text);

    if key.is_empty() {
        bail!("Expected a key.");
    }

    const YES: f32 = 36000.0;

    match key {
        "update_frequency" => config.update_frequency = parse_sane_u32(value, 5, 1000)?,
        "range" => config.range = parse_sane_f32(value, 3.0, YES)?,
        "horn_radius" => config.horn_radius = parse_sane_f32(value, 0.0, YES)?,
        "pressure_threshold" => config.pressure_threshold = parse_sane_u32(value, 0, u32::MAX)?,

        "base_radius" => config.base_radius = parse_sane_f32(value, 0.0, YES)?,
        "inertia" => config.inertia = parse_sane_f32(value, 0.01, YES)?,
        "friction" => config.friction = parse_sane_f32(value, 0.0, YES)?,
        "spring" => config.spring = parse_sane_f32(value, -YES, YES)?,
        "max_torque" => config.max_torque = parse_sane_f32(value, -YES, YES)?,

        "map_input_rect" => {
            (
                config.mapping.min_in_x,
                config.mapping.min_in_y,
                config.mapping.max_in_x,
                config.mapping.max_in_y,
            ) = parse_mapping_rect(value)?
        }
        "map_output_rect" => {
            (
                config.mapping.min_out_x,
                config.mapping.min_out_y,
                config.mapping.max_out_x,
                config.mapping.max_out_y,
            ) = parse_mapping_rect(value)?
        }
        "map_orientation" => config.mapping.orientation = parse_mapping_orientation(value)?,
        "map_invert" => {
            (config.mapping.invert_x, config.mapping.invert_y) = parse_mapping_invert(value)?
        }

        "net_sock_addr" => config.net_sock_addr = value.to_owned(),

        "device_resolution" => config.device_resolution = parse_sane_u32(value, 2, 32768)?,
        "device_name" => config.device_name = value.to_owned(),
        "device_id" => {
            (
                config.device_vendor,
                config.device_product,
                config.device_version,
            ) = parse_device_id(value)?
        }

        "preferred_tablet" => {
            config.preferred_tablet = (!value.is_empty()).then(|| value.to_owned())
        }

        "source" => config.source = parse_source(value)?,
        "device" => config.device = parse_device(value)?,

        _ => bail!("{key} is not a known configuration item."),
    }

    Ok(())
}

fn tokenise_kv_line(text: &str) -> (&str, &str) {
    let text = text.trim();

    let Some(index) = text.find('=') else {
        let len = text.len();
        let empty = &text[len - 1..len];
        return (text, empty);
    };

    let (k, v) = text.split_at(index);

    // `v` will always be at least 1 char long because the '=' is there.
    (k.trim(), v[1..].trim())
}

fn parse_sane_u32(text: &str, min: u32, max: u32) -> Result<u32> {
    let Ok(n) = text.parse::<u32>() else {
        bail!("\"{text}\" is not a positive integer.")
    };

    if n < min || n > max {
        bail!("{n} is out of the bounds: [{min}, {max}]");
    }

    Ok(n)
}

fn parse_sane_f32(text: &str, min: f32, max: f32) -> Result<f32> {
    let Ok(x) = text.parse::<f32>() else {
        bail!("\"{text}\" is not a number.")
    };

    if !x.is_finite() {
        bail!("{x} is bogus.")
    }

    if x < min || x > max {
        bail!("{x} is out of the bounds: [{min}, {max}]");
    }

    Ok(x)
}

fn parse_device_id(text: &str) -> Result<(u16, u16, u16)> {
    let mut tokens = text.split_whitespace();
    let vendor = tokens.next().context("Missing vendor code.")?;
    let product = tokens.next().context("Missing product code.")?;
    let version = tokens.next().context("Missing version code.")?;

    Ok((
        parse_hex_u16(vendor).context("Not a vendor code.")?,
        parse_hex_u16(product).context("Not a product code.")?,
        parse_hex_u16(version).context("Not a version code.")?,
    ))
}

fn parse_hex_u16(text: &str) -> Result<u16> {
    let clean = text.trim().trim_start_matches("0x");
    u16::from_str_radix(clean, 16).context("Invalid hexadecimal u16.")
}

fn parse_mapping_rect(text: &str) -> Result<(f32, f32, f32, f32)> {
    let mut tokens = text.split_whitespace();
    let min_x = tokens.next().context("Missing minimum X.")?;
    let min_y = tokens.next().context("Missing minimum Y.")?;
    let max_x = tokens.next().context("Missing maximum X.")?;
    let max_y = tokens.next().context("Missing maximum Y.")?;

    Ok((
        parse_sane_f32(min_x, -1000000.0, 1000000.0)?,
        parse_sane_f32(min_y, -1000000.0, 1000000.0)?,
        parse_sane_f32(max_x, -1000000.0, 1000000.0)?,
        parse_sane_f32(max_y, -1000000.0, 1000000.0)?,
    ))
}

fn parse_mapping_orientation(text: &str) -> Result<MapOrientation> {
    Ok(match text.trim() {
        "A0" => MapOrientation::None,
        "A90" => MapOrientation::A90,
        "A180" => MapOrientation::A180,
        "A270" => MapOrientation::A270,
        unknown => bail!("Unknown orientation \"{unknown}\""),
    })
}

fn parse_mapping_invert(text: &str) -> Result<(bool, bool)> {
    let mut x = false;
    let mut y = false;

    for c in text.chars() {
        if c.to_ascii_lowercase() == 'x' {
            x = true;
        } else if c.to_ascii_lowercase() == 'y' {
            y = true;
        } else if !c.is_whitespace() {
            bail!("Invalid axis character {c}!");
        }
    }

    Ok((x, y))
}

fn parse_source(text: &str) -> Result<Source> {
    Ok(match text.to_lowercase().as_str() {
        "" | "none" => Source::None,
        "net" => Source::Net,
        #[cfg(target_os = "windows")]
        "wintab" => Source::Wintab,
        #[cfg(target_os = "linux")]
        "evdev" => Source::Evdev,
        _ => bail!("No such \"{text}\" source."),
    })
}

fn parse_device(text: &str) -> Result<Device> {
    Ok(match text.to_lowercase().as_str() {
        "" | "none" => Device::None,
        #[cfg(target_os = "linux")]
        "uinput" => Device::UInput,
        #[cfg(target_os = "windows")]
        "vigembus" => Device::VigemBus,
        _ => bail!("No such \"{text}\" device."),
    })
}
